# Multiple-evaluation expressions (mevlexes)

> ## TL;DR - Don't mix impure expressions and mevlexes
>
> A mevlex is just an expression.
> You can use mevlexes just as you would use any other expression.
>
> Just be careful **not to provide an impure expression** as any of their [critical operands](./intro.md#critical-operands), or you may be surprised by the result.

_**M**ultiple **ev**a**l**uation **ex**pressions_, or _mevlexes_ are a set of expressions that evaluate an operand expression multiple times despite that operand only appearing once, syntactically.

For instance, when using a [range check](./range_checking.md) expression `v in low =.= high`, the expression `v` is evaluated twice in the resulting Java, despite only appearing once in the source code.

As a concrete example, this:

```sand
let isDigit = getInt() in 0 =.= 9;
```

...compiles to this:

```java
boolean isDigit = 0 <= getInt() && getInt() <= 9;
```

Notice that `getInt()` appears once in the source code (Sand) but twice in the generated code (Java).

## Critical operands

An operand of a mevlex that is evaluated multiple times is called a _critical operand_.

In the above example, the mevlex `getInt() in 0 =.= 9` has one critical operand: `getInt()`.

Why do critical operands matter?
Keep reading to find out!

## Impure expressions should not be critical operands

Using an _impure_ expression as a critical operand can easily result in unexpected behavior, and should therefore be avoided when possible.

### Wait, what's purity?

For those not familiar with [function purity](https://en.wikipedia.org/wiki/Pure_function), an impure expression is any expression that either causes side-effects (e.g., printing to stdout, changing a variable), or evaluates to different values when evaluated multiple times.
Some examples of impure expressions include:

- `System.out.println("Hi");` - causes side effect
- `x += 2;` - causes side effect
- `Math.random()` - results in different values
- `iterator.next()` - both causes side effect and results in different values

### Why impure expressions should not be critical operands

Consider the following, seemingly inoccuous, code:

```sand
let isFirstNumberDigit = intIterator.next() in 0 =.= 9;
```

The above code seems to do the following:

1. Get the next item of `intIterator`
2. Check if that value is between `0` and `9`, inclusive
3. Store the resulting boolean in `isFirstNumberDigit`

However, this is the Java code that is generated by the compiler:

```java
boolean isFirstNumberDigit = 0 <= intIterator.next() && intIterator.next() <= 9;
```

As you can see, the impure expression `intIterator.next()` is evaluated twice, which consumes and yields 2 different items from the iterator instead of the expected 1.

As a result, this is what the code actually does:

1. Get the next item of `intIterator`
2. Check if that value is greater than or equal to `0`
3. Get the _next_ item of `intIterator` (this is the second invocation of `next()`)
4. Check if that value (returned by the second invocation) is less than or equal to `9`
5. Store the resulting boolean in `isFirstNumberDigit`

In conclusion, since the critical operands get evaluated twice despite only syntactically appearing once, this can produce unexpected behavior, and should therefore be avoided when possible.
